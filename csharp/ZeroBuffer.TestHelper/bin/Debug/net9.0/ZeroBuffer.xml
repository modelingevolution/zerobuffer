<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ZeroBuffer</name>
    </assembly>
    <members>
        <member name="T:ZeroBuffer.ZeroBufferException">
            <summary>
            Base exception for ZeroBuffer operations
            </summary>
        </member>
        <member name="T:ZeroBuffer.BufferFullException">
            <summary>
            Thrown when the buffer is full and cannot accept more frames
            </summary>
        </member>
        <member name="T:ZeroBuffer.FrameTooLargeException">
            <summary>
            Thrown when a frame is too large for the buffer
            </summary>
        </member>
        <member name="T:ZeroBuffer.WriterDeadException">
            <summary>
            Thrown when the writer process has died
            </summary>
        </member>
        <member name="T:ZeroBuffer.ReaderDeadException">
            <summary>
            Thrown when the reader process has died
            </summary>
        </member>
        <member name="T:ZeroBuffer.BufferNotFoundException">
            <summary>
            Thrown when trying to connect to a non-existent buffer
            </summary>
        </member>
        <member name="T:ZeroBuffer.WriterAlreadyConnectedException">
            <summary>
            Thrown when another writer is already connected
            </summary>
        </member>
        <member name="T:ZeroBuffer.ReaderAlreadyConnectedException">
            <summary>
            Thrown when another reader is already connected
            </summary>
        </member>
        <member name="T:ZeroBuffer.IFileLock">
            <summary>
            Abstraction for cross-platform file locking to track resource ownership
            </summary>
        </member>
        <member name="P:ZeroBuffer.IFileLock.IsLocked">
            <summary>
            Check if lock is successfully held
            </summary>
        </member>
        <member name="T:ZeroBuffer.FileLockFactory">
            <summary>
            Factory for creating platform-specific file lock implementations
            </summary>
        </member>
        <member name="T:ZeroBuffer.ISemaphore">
            <summary>
            Abstraction for cross-platform named semaphore operations
            </summary>
        </member>
        <member name="M:ZeroBuffer.ISemaphore.Wait(System.Nullable{System.TimeSpan})">
            <summary>
            Waits on the semaphore with optional timeout
            </summary>
            <returns>True if acquired, false if timed out</returns>
        </member>
        <member name="M:ZeroBuffer.ISemaphore.Release">
            <summary>
            Releases the semaphore
            </summary>
        </member>
        <member name="M:ZeroBuffer.ISemaphore.TryWait">
            <summary>
            Tries to acquire the semaphore without blocking
            </summary>
        </member>
        <member name="T:ZeroBuffer.SemaphoreFactory">
            <summary>
            Factory for creating platform-specific semaphore implementations
            </summary>
        </member>
        <member name="T:ZeroBuffer.ISharedMemory">
            <summary>
            Abstraction for cross-platform shared memory operations
            </summary>
        </member>
        <member name="P:ZeroBuffer.ISharedMemory.Name">
            <summary>
            Gets the name of the shared memory segment
            </summary>
        </member>
        <member name="P:ZeroBuffer.ISharedMemory.Size">
            <summary>
            Gets the size of the shared memory segment
            </summary>
        </member>
        <member name="M:ZeroBuffer.ISharedMemory.Read``1(System.Int64)">
            <summary>
            Reads a structure from the specified offset
            </summary>
        </member>
        <member name="M:ZeroBuffer.ISharedMemory.ReadRef``1(System.Int64)">
            <summary>
            Gets a readonly reference to a structure at the specified offset (zero-copy)
            </summary>
        </member>
        <member name="M:ZeroBuffer.ISharedMemory.Write``1(System.Int64,``0@)">
            <summary>
            Writes a structure to the specified offset
            </summary>
        </member>
        <member name="M:ZeroBuffer.ISharedMemory.ReadArray(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads an array from the specified offset
            </summary>
        </member>
        <member name="M:ZeroBuffer.ISharedMemory.WriteArray(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes an array to the specified offset
            </summary>
        </member>
        <member name="M:ZeroBuffer.ISharedMemory.WriteSpan(System.Int64,System.ReadOnlySpan{System.Byte})">
            <summary>
            Writes a span to the specified offset (zero allocation)
            </summary>
        </member>
        <member name="M:ZeroBuffer.ISharedMemory.Flush">
            <summary>
            Ensures memory changes are visible to other processes
            </summary>
        </member>
        <member name="M:ZeroBuffer.ISharedMemory.GetPointer(System.Int64)">
            <summary>
            Get unsafe pointer to the shared memory at the specified offset
            For zero-copy access
            </summary>
        </member>
        <member name="T:ZeroBuffer.SharedMemoryFactory">
            <summary>
            Factory for creating platform-specific shared memory implementations
            </summary>
        </member>
        <member name="T:ZeroBuffer.PosixFileLock">
            <summary>
            POSIX implementation of file locking using flock
            </summary>
        </member>
        <member name="M:ZeroBuffer.PosixFileLock.TryRemoveStale(System.String)">
            <summary>
            Try to remove a stale lock file
            </summary>
        </member>
        <member name="T:ZeroBuffer.PosixInterop">
            <summary>
            P/Invoke declarations for POSIX shared memory and semaphore functions
            </summary>
        </member>
        <member name="T:ZeroBuffer.PosixSemaphore">
            <summary>
            POSIX implementation of named semaphore
            </summary>
        </member>
        <member name="M:ZeroBuffer.PosixSemaphore.Remove(System.String)">
            <summary>
            Removes semaphore by name (static method for cleanup)
            </summary>
        </member>
        <member name="T:ZeroBuffer.PosixSharedMemory">
            <summary>
            POSIX implementation of shared memory using shm_open/mmap
            </summary>
        </member>
        <member name="M:ZeroBuffer.PosixSharedMemory.Remove(System.String)">
            <summary>
            Removes shared memory by name (static method for cleanup)
            </summary>
        </member>
        <member name="T:ZeroBuffer.Reader">
            <summary>
            Cross-platform Reader implementation using abstracted shared memory and semaphores
            </summary>
        </member>
        <member name="M:ZeroBuffer.Reader.GetMetadata">
            <summary>
            Get metadata - zero-copy access via ReadOnlySpan
            </summary>
        </member>
        <member name="M:ZeroBuffer.Reader.ReadFrame(System.Nullable{System.TimeSpan})">
            <summary>
            Read a frame from the buffer
            </summary>
        </member>
        <member name="M:ZeroBuffer.Reader.IsWriterConnected">
            <summary>
            Check if a writer is connected
            </summary>
        </member>
        <member name="T:ZeroBuffer.CrossProcessSemaphore">
            <summary>
            Wrapper around .NET's built-in Semaphore for cross-process synchronization
            .NET's Semaphore already supports named semaphores for IPC
            </summary>
        </member>
        <member name="M:ZeroBuffer.CrossProcessSemaphore.Create(System.String,System.Int32,System.Int32)">
            <summary>
            Create a new named semaphore using .NET's built-in Semaphore
            </summary>
        </member>
        <member name="M:ZeroBuffer.CrossProcessSemaphore.Open(System.String)">
            <summary>
            Open an existing named semaphore using .NET's built-in Semaphore.OpenExisting
            </summary>
        </member>
        <member name="M:ZeroBuffer.CrossProcessSemaphore.Wait(System.TimeSpan)">
            <summary>
            Wait for the semaphore with timeout
            </summary>
        </member>
        <member name="M:ZeroBuffer.CrossProcessSemaphore.Release">
            <summary>
            Release the semaphore
            </summary>
        </member>
        <member name="T:ZeroBuffer.Constants">
            <summary>
            Block alignment requirement for all blocks
            </summary>
        </member>
        <member name="T:ZeroBuffer.OIEB">
            <summary>
            Operation Info Exchange Block structure
            Must match the C++ OIEB structure exactly for cross-language compatibility
            </summary>
        </member>
        <member name="M:ZeroBuffer.OIEB.CalculateUsedBytes">
            <summary>
            Calculate used bytes in the buffer (optimized with ref readonly)
            </summary>
        </member>
        <member name="M:ZeroBuffer.OIEB.HasSpaceFor(System.UInt64)">
            <summary>
            Check if there's enough space for a frame (optimized)
            </summary>
        </member>
        <member name="T:ZeroBuffer.FrameHeader">
            <summary>
            Frame header structure
            </summary>
        </member>
        <member name="T:ZeroBuffer.BufferConfig">
            <summary>
            Configuration for creating a buffer
            </summary>
        </member>
        <member name="T:ZeroBuffer.Frame">
            <summary>
            Frame reference for TRUE zero-copy access
            Using unsafe pointers for direct memory access without any copying
            </summary>
        </member>
        <member name="P:ZeroBuffer.Frame.Span">
            <summary>
            Get span for direct zero-copy access to frame data in shared memory
            </summary>
        </member>
        <member name="M:ZeroBuffer.Frame.ToArray">
            <summary>
            Copy frame data to a byte array (only use when a copy is truly needed)
            </summary>
        </member>
        <member name="T:ZeroBuffer.WindowsFileLock">
            <summary>
            Windows implementation of file locking
            </summary>
        </member>
        <member name="M:ZeroBuffer.WindowsFileLock.TryRemoveStale(System.String)">
            <summary>
            Try to remove a stale lock file
            </summary>
        </member>
        <member name="T:ZeroBuffer.WindowsSemaphore">
            <summary>
            Windows implementation of named semaphore using System.Threading.Semaphore
            </summary>
        </member>
        <member name="T:ZeroBuffer.WindowsSharedMemory">
            <summary>
            Windows implementation of shared memory using MemoryMappedFile
            </summary>
        </member>
        <member name="T:ZeroBuffer.Writer">
            <summary>
            Cross-platform Writer implementation using abstracted shared memory and semaphores
            </summary>
        </member>
        <member name="M:ZeroBuffer.Writer.GetMetadataBuffer(System.Int32)">
            <summary>
            Get metadata buffer for zero-copy writing
            Returns a span where you can write metadata directly
            </summary>
        </member>
        <member name="M:ZeroBuffer.Writer.CommitMetadata">
            <summary>
            Commit metadata after writing to the buffer returned by GetMetadataBuffer
            </summary>
        </member>
        <member name="M:ZeroBuffer.Writer.SetMetadata(System.ReadOnlySpan{System.Byte})">
            <summary>
            Set metadata (convenience method that copies data)
            For zero-copy writing, use GetMetadataBuffer/CommitMetadata instead
            </summary>
        </member>
        <member name="M:ZeroBuffer.Writer.GetFrameBuffer(System.Int32,System.UInt64@)">
            <summary>
            Get a buffer for writing frame data directly (zero-copy write)
            Returns a span where you can write your data directly
            Call CommitFrame() after writing to complete the operation
            </summary>
        </member>
        <member name="M:ZeroBuffer.Writer.CommitFrame">
            <summary>
            Commit the frame after writing to the buffer returned by GetFrameBuffer
            </summary>
        </member>
        <member name="M:ZeroBuffer.Writer.WriteFrame(System.ReadOnlySpan{System.Byte})">
            <summary>
            Write a frame to the buffer (convenience method that copies data)
            For zero-copy writing, use GetFrameBuffer/CommitFrame instead
            </summary>
        </member>
        <member name="M:ZeroBuffer.Writer.IsReaderConnected">
            <summary>
            Check if reader is connected
            </summary>
        </member>
    </members>
</doc>
