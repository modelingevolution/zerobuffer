using System.Text;
using System.Text.RegularExpressions;
using Gherkin.Ast;

namespace HarmonyCppGen;

public class TestFileGenerator
{
    private readonly Feature _feature;
    private readonly string _fileName;
    private readonly string _namespace;
    private readonly StringBuilder _output = new();
    private int _indentLevel = 0;
    
    public TestFileGenerator(Feature feature, string fileName, string cppNamespace)
    {
        _feature = feature;
        _fileName = fileName;
        _namespace = cppNamespace;
    }
    
    public string Generate()
    {
        WriteHeader();
        WriteIncludes();
        WriteTestFixture();
        WriteTests();
        
        return _output.ToString();
    }
    
    private void WriteHeader()
    {
        WriteLine("// Generated from: " + _fileName);
        WriteLine("// DO NOT EDIT - This file is auto-generated by harmony-cpp-gen");
        WriteLine();
    }
    
    private void WriteIncludes()
    {
        WriteLine("#include <gtest/gtest.h>");
        WriteLine("#include <memory>");
        WriteLine("#include <string>");
        WriteLine("#include <vector>");
        WriteLine("#include \"step_definitions/step_registry.h\"");
        WriteLine("#include \"step_definitions/test_context.h\"");
        WriteLine("#include <zerobuffer/logger.h>");
        
        WriteLine();
        WriteLine($"using namespace {_namespace};");
        WriteLine();
    }
    
    private void WriteTestFixture()
    {
        var fixtureName = GetFixtureName(_fileName);
        
        // Define StepType enum
        WriteLine("enum class StepType {");
        Indent();
        WriteLine("Given,");
        WriteLine("When,");
        WriteLine("Then,");
        WriteLine("And,");
        WriteLine("But");
        Unindent();
        WriteLine("};");
        WriteLine();
        
        WriteLine($"class {fixtureName} : public ::testing::Test {{");
        WriteLine("protected:");
        Indent();
        WriteLine("StepRegistry& registry = StepRegistry::getInstance();");
        WriteLine("TestContext context;");
        WriteLine();
        WriteLine("void SetUp() override {");
        Indent();
        WriteLine("// Register all available step definitions");
        WriteLine("registry.registerAllSteps();");
        WriteLine("context.reset();");
        Unindent();
        WriteLine("}");
        WriteLine();
        WriteLine("void TearDown() override {");
        Indent();
        WriteLine("// Clean up any resources");
        WriteLine("context.reset();");
        Unindent();
        WriteLine("}");
        WriteLine();
        WriteLine("bool ExecuteStep(StepType type, const std::string& step) {");
        Indent();
        WriteLine("// Log SpecFlow-like output using logger (not stdout for JSON-RPC compatibility)");
        WriteLine("const char* keyword = \"Given\";");
        WriteLine("switch(type) {");
        WriteLine("    case StepType::Given: keyword = \"Given\"; break;");
        WriteLine("    case StepType::When: keyword = \"When\"; break;");
        WriteLine("    case StepType::Then: keyword = \"Then\"; break;");
        WriteLine("    case StepType::And: keyword = \"  And\"; break;");
        WriteLine("    case StepType::But: keyword = \"  But\"; break;");
        WriteLine("}");
        WriteLine("// Use INFO level for step execution output (SpecFlow-like format)");
        WriteLine("ZEROBUFFER_LOG_INFO(\"TestRunner\") << keyword << \" \" << step;");
        WriteLine();
        WriteLine("bool result = registry.executeStep(step, context);");
        WriteLine("if (!result) {");
        WriteLine("    ZEROBUFFER_LOG_ERROR(\"TestRunner\") << \"  âœ— Step not found: \" << step;");
        WriteLine("}");
        WriteLine("return result;");
        Unindent();
        WriteLine("}");
        Unindent();
        WriteLine("};");
        WriteLine();
    }
    
    private void WriteTests()
    {
        foreach (var child in _feature.Children)
        {
            if (child is Scenario scenario)
            {
                WriteScenarioTest(scenario);
            }
        }
    }
    
    private void WriteScenarioTest(Scenario scenario)
    {
        var fixtureName = GetFixtureName(_fileName);
        var testName = SanitizeTestName(scenario.Name);
        
        WriteLine($"TEST_F({fixtureName}, {testName}) {{");
        Indent();
        
        // Add a comment with the original scenario name
        WriteLine($"// Scenario: {scenario.Name}");
        WriteLine();
        
        // Process background steps if any
        if (_feature.Children.Any(c => c is Background))
        {
            var background = _feature.Children.First(c => c is Background) as Background;
            if (background != null)
            {
                WriteLine("// Background steps");
                foreach (var step in background.Steps)
                {
                    WriteStepExecution(step);
                }
                WriteLine();
            }
        }
        
        // Process scenario steps
        WriteLine("// Scenario steps");
        foreach (var step in scenario.Steps)
        {
            WriteStepExecution(step);
        }
        
        Unindent();
        WriteLine("}");
        WriteLine();
    }
    
    private void WriteStepExecution(Step step)
    {
        var stepText = EscapeString(step.Text);
        var keyword = step.Keyword.Trim();
        
        // Map keyword to enum value
        var keywordEnum = keyword.ToLower() switch
        {
            "given" => "StepType::Given",
            "when" => "StepType::When",
            "then" => "StepType::Then",
            "and" => "StepType::And",
            "but" => "StepType::But",
            _ => "StepType::Given" // Default fallback
        };
        
        // Add comment with original step
        WriteLine($"// {keyword} {step.Text}");
        
        // Generate ASSERT with keyword for SpecFlow-like output
        WriteLine($"ASSERT_TRUE(ExecuteStep({keywordEnum}, \"{stepText}\")) << \"Failed: {keyword} {stepText}\";");
    }
    
    private string GetFixtureName(string fileName)
    {
        var baseName = GetBaseFeatureName(fileName);
        return baseName + "Test";
    }
    
    private string GetBaseFeatureName(string fileName)
    {
        var name = Path.GetFileNameWithoutExtension(fileName);
        
        // Remove leading numbers and dash (e.g., "01-BasicCommunication" -> "BasicCommunication")
        if (name.Contains('-'))
        {
            name = name.Substring(name.IndexOf('-') + 1);
        }
        
        // Convert to PascalCase if needed
        return ToPascalCase(name);
    }
    
    private string ToPascalCase(string text)
    {
        // Already in PascalCase
        if (char.IsUpper(text[0]))
            return text;
        
        // Convert from snake_case or kebab-case
        var words = text.Split(new[] { '_', '-' }, StringSplitOptions.RemoveEmptyEntries);
        return string.Join("", words.Select(w => char.ToUpper(w[0]) + w.Substring(1).ToLower()));
    }
    
    private static string ToSnakeCase(string text)
    {
        var result = new StringBuilder();
        for (int i = 0; i < text.Length; i++)
        {
            var c = text[i];
            if (char.IsUpper(c))
            {
                if (i > 0 && !char.IsUpper(text[i - 1]))
                    result.Append('_');
                result.Append(char.ToLower(c));
            }
            else if (c == ' ' || c == '-')
            {
                result.Append('_');
            }
            else
            {
                result.Append(c);
            }
        }
        return result.ToString();
    }
    
    private string SanitizeTestName(string name)
    {
        // Remove special characters and convert to valid C++ identifier
        var sanitized = Regex.Replace(name, @"[^\w\d]", "_");
        
        // Remove consecutive underscores
        sanitized = Regex.Replace(sanitized, @"_+", "_");
        
        // Remove leading/trailing underscores
        sanitized = sanitized.Trim('_');
        
        // Ensure it doesn't start with a number
        if (sanitized.Length > 0 && char.IsDigit(sanitized[0]))
        {
            sanitized = "Test_" + sanitized;
        }
        
        return sanitized;
    }
    
    private string EscapeString(string text)
    {
        // Escape backslashes first, then quotes
        return text.Replace("\\", "\\\\").Replace("\"", "\\\"");
    }
    
    private void WriteLine(string line = "")
    {
        if (string.IsNullOrEmpty(line))
        {
            _output.AppendLine();
        }
        else
        {
            _output.AppendLine(new string(' ', _indentLevel * 4) + line);
        }
    }
    
    private void Indent() => _indentLevel++;
    private void Unindent() => _indentLevel = Math.Max(0, _indentLevel - 1);
}