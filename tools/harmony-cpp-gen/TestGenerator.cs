using System.Text;
using Gherkin;
using Gherkin.Ast;

namespace HarmonyCppGen;

public class TestGenerator
{
    private readonly bool _verbose;
    private readonly Parser _parser = new();
    
    public TestGenerator(bool verbose = false)
    {
        _verbose = verbose;
    }
    
    public async Task GenerateTests(DirectoryInfo inputDir, DirectoryInfo outputDir, string? filter, string cppNamespace)
    {
        if (!inputDir.Exists)
        {
            Console.WriteLine($"Error: Input directory does not exist: {inputDir.FullName}");
            Environment.Exit(1);
        }
        
        if (!outputDir.Exists)
        {
            outputDir.Create();
            if (_verbose) Console.WriteLine($"Created output directory: {outputDir.FullName}");
        }
        
        var featureFiles = inputDir.GetFiles("*.feature", SearchOption.TopDirectoryOnly)
            .Where(f => string.IsNullOrEmpty(filter) || f.Name.Contains(filter, StringComparison.OrdinalIgnoreCase))
            .OrderBy(f => f.Name)
            .ToArray();
        
        Console.WriteLine($"Processing {featureFiles.Length} feature files...");
        
        var generatedFiles = new List<string>();
        
        foreach (var featureFile in featureFiles)
        {
            try
            {
                if (_verbose) Console.WriteLine($"Parsing: {featureFile.Name}");
                
                var gherkinDocument = _parser.Parse(featureFile.FullName);
                
                if (gherkinDocument.Feature == null)
                {
                    Console.WriteLine($"  ⚠ Skipping {featureFile.Name} - no feature found");
                    continue;
                }
                
                var generator = new TestFileGenerator(gherkinDocument.Feature, featureFile.Name, cppNamespace);
                var cppContent = generator.Generate();
                
                var outputFileName = GetOutputFileName(featureFile.Name);
                var outputPath = Path.Combine(outputDir.FullName, outputFileName);
                
                await File.WriteAllTextAsync(outputPath, cppContent);
                generatedFiles.Add(outputFileName);
                
                Console.WriteLine($"  ✓ Generated: {outputFileName}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"  ✗ Error processing {featureFile.Name}: {ex.Message}");
                if (_verbose)
                {
                    Console.WriteLine($"    Stack trace: {ex.StackTrace}");
                }
            }
        }
        
        // Generate CMakeLists.txt
        if (generatedFiles.Any())
        {
            await GenerateCMakeLists(outputDir, generatedFiles);
            Console.WriteLine($"  ✓ Generated: CMakeLists.txt");
        }
        
        Console.WriteLine($"\n✅ Successfully generated {generatedFiles.Count} test files in {outputDir.FullName}");
        
        // Print usage instructions
        Console.WriteLine("\nTo build and run the generated tests:");
        Console.WriteLine("  1. Add 'add_subdirectory(path/to/generated)' to your CMakeLists.txt");
        Console.WriteLine("  2. Build: cmake .. && make");
        Console.WriteLine("  3. Run: ./zerobuffer_generated_tests");
    }
    
    private static string GetOutputFileName(string featureFileName)
    {
        var name = Path.GetFileNameWithoutExtension(featureFileName);
        
        // Remove leading numbers and dash
        if (name.Contains('-'))
            name = name.Substring(name.IndexOf('-') + 1);
        
        // Convert to snake_case
        var snakeCase = ToSnakeCase(name);
        return $"test_{snakeCase}.cpp";
    }
    
    private static string ToSnakeCase(string text)
    {
        var result = new StringBuilder();
        for (int i = 0; i < text.Length; i++)
        {
            var c = text[i];
            if (char.IsUpper(c))
            {
                if (i > 0 && !char.IsUpper(text[i - 1]))
                    result.Append('_');
                result.Append(char.ToLower(c));
            }
            else if (c == ' ' || c == '-')
            {
                result.Append('_');
            }
            else
            {
                result.Append(c);
            }
        }
        return result.ToString();
    }
    
    private async Task GenerateCMakeLists(DirectoryInfo outputDir, List<string> generatedFiles)
    {
        var sb = new StringBuilder();
        sb.AppendLine("# Auto-generated by harmony-cpp-gen");
        sb.AppendLine("# DO NOT EDIT - This file is auto-generated");
        sb.AppendLine();
        sb.AppendLine("cmake_minimum_required(VERSION 3.20)");
        sb.AppendLine();
        sb.AppendLine("# Generated test sources");
        sb.AppendLine("set(GENERATED_TEST_SOURCES");
        
        foreach (var file in generatedFiles)
        {
            sb.AppendLine($"    ${{CMAKE_CURRENT_SOURCE_DIR}}/{file}");
        }
        
        sb.AppendLine(")");
        sb.AppendLine();
        sb.AppendLine("# Create test executable");
        sb.AppendLine("add_executable(zerobuffer_generated_tests");
        sb.AppendLine("    ${GENERATED_TEST_SOURCES}");
        sb.AppendLine(")");
        sb.AppendLine();
        sb.AppendLine("# Add step definition sources directly");
        sb.AppendLine("set(STEP_DEFINITION_SOURCES");
        sb.AppendLine("    ${CMAKE_SOURCE_DIR}/step_definitions/step_registry.cpp");
        sb.AppendLine("    ${CMAKE_SOURCE_DIR}/step_definitions/test_context.cpp");
        sb.AppendLine("    ${CMAKE_SOURCE_DIR}/step_definitions/basic_communication_steps.cpp");
        sb.AppendLine("    # Add more step definition files as they are implemented:");
        sb.AppendLine("    # ${CMAKE_SOURCE_DIR}/step_definitions/edge_cases_steps.cpp");
        sb.AppendLine("    # ${CMAKE_SOURCE_DIR}/step_definitions/error_handling_steps.cpp");
        sb.AppendLine("    # etc.");
        sb.AppendLine(")");
        sb.AppendLine();
        sb.AppendLine("# Add step definitions to the test executable");
        sb.AppendLine("target_sources(zerobuffer_generated_tests");
        sb.AppendLine("    PRIVATE");
        sb.AppendLine("    ${STEP_DEFINITION_SOURCES}");
        sb.AppendLine(")");
        sb.AppendLine();
        sb.AppendLine("# Link with required libraries");
        sb.AppendLine("target_link_libraries(zerobuffer_generated_tests");
        sb.AppendLine("    PRIVATE");
        sb.AppendLine("    zerobuffer");
        sb.AppendLine("    nlohmann_json::nlohmann_json");
        sb.AppendLine("    GTest::gtest");
        sb.AppendLine("    GTest::gtest_main");
        sb.AppendLine("    Threads::Threads");
        sb.AppendLine(")");
        sb.AppendLine();
        sb.AppendLine("# Include directories");
        sb.AppendLine("target_include_directories(zerobuffer_generated_tests");
        sb.AppendLine("    PRIVATE");
        sb.AppendLine("    ${CMAKE_SOURCE_DIR}");
        sb.AppendLine("    ${CMAKE_SOURCE_DIR}/step_definitions");
        sb.AppendLine(")");
        sb.AppendLine();
        sb.AppendLine("# Set C++ standard");
        sb.AppendLine("target_compile_features(zerobuffer_generated_tests PRIVATE cxx_std_20)");
        sb.AppendLine();
        sb.AppendLine("# Add tests to CTest");
        sb.AppendLine("include(GoogleTest)");
        sb.AppendLine("gtest_discover_tests(zerobuffer_generated_tests");
        sb.AppendLine("    PROPERTIES TIMEOUT 30");
        sb.AppendLine(")");
        
        var cmakeListsPath = Path.Combine(outputDir.FullName, "CMakeLists.txt");
        await File.WriteAllTextAsync(cmakeListsPath, sb.ToString());
    }
}